void _rotacion::parametros(vector<_vertex3f> perfil, int num, int tipo,
                           int tapa_in, int tapa_su) {
  int i, j;
  _vertex3f vertice_aux;
  _vertex3i cara_aux;
  int num_aux;  // Tamaño del perfil
  float radio;

  // tratamiento de los vértice

  num_aux = perfil.size();

  if (tipo == 1)
    num_aux -= 1;  // Si es un cono el número de vertices del perfil = 1
  if (tipo == 2)
    radio = sqrt(perfil[0].x * perfil[0].x +
                 perfil[0].y * perfil[0].y);  // Para el circulo

  vertices.resize(num_aux * num);  //+1 = vertice central de las tapaderas = +2

  // giro en el eje X, pa programar otros ejes mirar diapositiva
  for (j = 0; j < num; j++) {
    for (i = 0; i < num_aux; i++) {
      vertice_aux.x =
          perfil[i].x * cos(2.0 * M_PI * j / (1.0 * num)) +  // 360º (en radianes) /num
          perfil[i].z * sin(2.0 * M_PI * j / (1.0 * num));
      vertice_aux.z = 
          -perfil[i].x * sin(2.0 * M_PI * j / (1.0 * num)) +
          perfil[i].z * cos(2.0 * M_PI * j / (1.0 * num));
      vertice_aux.y = perfil[i].y;
      
      vertices[i + j * num_aux] = vertice_aux;
    }
  }

  // tratamiento de las caras
  // caras[0]._0=0;
  // caras[0]._1=num_aux;
  // caras[0]._2=1;

  // caras[1]._0=num_aux;
  // caras[1]._1=num_aux+1;
  // caras[1]._2=1;
  int num_caras = 2 * (num_aux - 1) * num + 2 * num;
  caras.resize(num_caras);  //+num?
  int c = 0;

  for (int j = 0; j < num; j++) {
    for (int i = 0; i < num_aux - 1; i++) {  // -1 porque es el número de segmentos que se pueden crear entre los puntos del perfil.
      caras[c]._0 = i + j * num_aux;
      caras[c]._1 = ((j + 1) % num) * num_aux + i;
      caras[c]._2 = 1 + i + j * num_aux;

      c++;

      caras[c]._0 = ((j + 1) % num) * num_aux + i;
      caras[c]._1 = ((j + 1) % num) * num_aux + i + 1;
      caras[c]._2 = 1 + i + j * num_aux;
      c++;
    }
  }

  int total_matriz = num_aux * num;

  // tapa inferior
  /*Consiste en colocar un punto en medio y crear triangulos a partir de los
   * vertices y el punto medio*/
  if (tapa_in == 1) {
    vertices.resize(vertices.size() + 1);
    vertices[total_matriz].x = 0.0;
    vertices[total_matriz].y = vertices[0].y;  // perfil[0] o vertices[]
    vertices[total_matriz].z = 0.0;

    if (tipo == 2) vertices[total_matriz].y = -radio;

    for (int j = 0; j < num; j++) {
      caras[c]._0 = j * num_aux;
      caras[c]._2 = ((j + 1) % num) * num_aux;
      caras[c]._1 = total_matriz;

      c++;
    }
  }

  // tapa superior
  if (tapa_su == 1) {
    vertices.resize(vertices.size() + 1);
    vertices[total_matriz + 1].x = 0.0;
    vertices[total_matriz + 1].y = vertices[num_aux - 1].y;
    vertices[total_matriz + 1].z = 0.0;

    if (tipo == 1) vertices[total_matriz + 1].y = perfil[perfil.size() - 1].y;
    if (tipo == 2) vertices[total_matriz + 1].y = radio;

    for (int j = 0; j < num; j++) {
      caras[c]._0 = total_matriz + 1;
      caras[c]._2 = ((j + 1) % num) * num_aux + num_aux - 1;
      caras[c]._1 = j * num_aux + num_aux - 1;

      c++;
    }
  }

  // Colores para los vertices
  colores_vertices.resize(total_matriz);  // color entre 0 y 1
  for (int i = 0; i < total_matriz; i++) {
    colores_vertices[i].r = rand() % 1000 / 1000.0;
    colores_vertices[i].g = rand() % 1000 / 1000.0;
    colores_vertices[i].b = rand() % 1000 / 1000.0;
  }


  //normales a caras
  calcular_normales_caras();

  // colores para las caras
  // colors_random();
  color_lambert_c (0, 10, 40, 1.0 ,0.8, 0);
}